// total runtime of the rollershutters
val int ROLLO_TIMEOUT = 10

// timers to switch it off after the timeout
val java.util.Map<String, org.openhab.model.script.actions.Timer> rolloTimers = newHashMap

// lambda expression that can be used as a function (here: with 5 parameters)
val org.eclipse.xtext.xbase.lib.Functions$Function5 rolloLogic = [
    org.openhab.core.library.items.SwitchItem relayItem,
    org.openhab.core.library.items.SwitchItem relayItemOpposite,
    java.util.Map<String, org.openhab.model.script.actions.Timer> timers,
    String timerKey, int timeout |
        // if current state is off
        if (relayItem.state == OFF) {
            // if opposite state is also off
            if (relayItemOpposite.state == OFF) {
                // switch it on!
                relayItem.sendCommand(ON)
                // if there is already a timer, cancel it
                timers.get(timerKey)?.cancel
                // now create a new timer for switching off
                timers.put(timerKey, createTimer(now.plusSeconds(timeout)) [|
                    // switch it off afterwards, if it is not already off
                    if (relayItem.state == ON)
                        relayItem.sendCommand(OFF)
                    // remove timer from map because nothing is ON anymore
                    timers.remove(timerKey)
                ])
            } else { // opposite is on
                // switch opposite off!
                relayItemOpposite.sendCommand(OFF)
            }
        } else { // it is already on
            // switch it off
            relayItem.sendCommand(OFF)
        }
]

// lambda expression that can be used as a function (here: with 5 parameters)
val org.eclipse.xtext.xbase.lib.Functions$Function5 rolloLogic2 = [
    org.openhab.core.library.items.SwitchItem relayItem,
    org.openhab.core.library.items.SwitchItem relayItemOpposite,
    java.util.Map<String, org.openhab.model.script.actions.Timer> timers,
    String timerKey, int timeout |
        // if opposite state is on
        if (relayItemOpposite.state == ON) 
		{   // switch opposite off!
            relayItemOpposite.sendCommand(OFF)
        }
        // if there is already a timer, cancel it
        timers.get(timerKey)?.cancel
        // now create a new timer for switching off
        timers.put(timerKey, createTimer(now.plusSeconds(timeout)) [|
            // switch it off afterwards, if it is not already off
            if (relayItem.state == ON)
                relayItem.sendCommand(OFF)
            // remove timer from map because nothing is ON anymore
            timers.remove(timerKey)
        ])
]

rule "rollo garage 2 up"
when Item R_GarDoor2_up changed to ON then
    rolloLogic2.apply(R_GarDoor2_up, R_GarDoor2_down, rolloTimers, "GarDoor2", 1)
end
rule "rollo garage 2 down"
when Item R_GarDoor2_down changed to ON then
    rolloLogic2.apply(R_GarDoor2_down, R_GarDoor2_up, rolloTimers, "GarDoor2", 1)
end

rule "voice test"
when
	Item VoiceCommand received command "open left door"
then
    R_GarDoor1_up.sendCommand(OFF)
end
